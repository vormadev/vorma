# Vorma Backend Guide

This guide covers the complete backend API surface of Vorma, a full-stack
Go/TypeScript framework. You'll learn how to set up a Vorma application from
scratch, understanding each component along the way.

## Directory Structure

The recommended structure separates backend and frontend concerns:

```
your-app/
├── backend/
│   ├── assets/              # Private static files (templates, etc.)
│   │   └── entry.go.html    # HTML template (REQUIRED)
│   ├── cmd/
│   │   ├── serve/
│   │   │   └── main.go      # Application entry point
│   │   └── build/
│   │       └── main.go      # Build command entry point
│   ├── dist/
│   │   └── static/
│   │       └── .keep        # Required for go:embed
│   ├── src/
│   │   └── router/
│   │       └── router.go    # App instance, loaders, actions
│   ├── wave.dev.go          # Dev-mode Wave initialization
│   ├── wave.prod.go         # Prod-mode Wave initialization
│   └── wave.config.json     # Configuration (REQUIRED)
├── frontend/
│   └── assets/              # Public static files
├── vite.config.ts
└── package.json
```

**Hard requirements:** `wave.config.json` and `entry.go.html` must exist. The
rest is convention.

---

## Step 1: Wave Configuration

Create `backend/wave.config.json`. This configures both Wave (the underlying
build system) and Vorma.

```json
{
	"$schema": "dist/static/internal/schema.json",
	"Core": {
		"ConfigLocation": "backend/wave.config.json",
		"MainAppEntry": "backend/cmd/serve",
		"DistDir": "backend/dist",
		"StaticAssetDirs": {
			"Private": "backend/assets",
			"Public": "frontend/assets"
		},
		"CSSEntryFiles": {
			"Critical": "frontend/src/styles/main.critical.css",
			"NonCritical": "frontend/src/styles/main.css"
		},
		"PublicPathPrefix": "/"
	},
	"Vorma": {
		"MainBuildEntry": "backend/cmd/build",
		"UIVariant": "react",
		"HTMLTemplateLocation": "entry.go.html",
		"ClientEntry": "frontend/src/vorma.entry.tsx",
		"ClientRouteDefsFile": "frontend/src/vorma.routes.ts",
		"TSGenOutDir": "frontend/src/vorma.gen",
		"BuildtimePublicURLFuncName": "waveBuildtimeURL"
	},
	"Vite": {
		"JSPackageManagerBaseCmd": "npx"
	},
	"Watch": {
		"HealthcheckEndpoint": "/healthz",
		"Include": []
	}
}
```

### Core Section (Required)

| Field                       | Required  | Description                                                                  |
| --------------------------- | --------- | ---------------------------------------------------------------------------- |
| `ConfigLocation`            | No        | Path to this file. Enables hot-reload on config changes.                     |
| `MainAppEntry`              | **Yes**   | Path to your server's main.go or its directory.                              |
| `DistDir`                   | **Yes**   | Output directory for compiled binary and processed assets.                   |
| `StaticAssetDirs.Private`   | **Yes\*** | Private assets (templates). \*Required unless `ServerOnlyMode: true`.        |
| `StaticAssetDirs.Public`    | **Yes\*** | Public assets (served to browser). \*Required unless `ServerOnlyMode: true`. |
| `CSSEntryFiles.Critical`    | No        | CSS inlined in `<head>` for fast initial render.                             |
| `CSSEntryFiles.NonCritical` | No        | CSS loaded asynchronously.                                                   |
| `PublicPathPrefix`          | No        | URL prefix for public assets. Default: `"/"`.                                |
| `SequentialGoBuild`         | No        | If `true`, Go compiles after build hooks (for generated Go code).            |

### Vorma Section (Required for Vorma apps)

| Field                        | Required | Description                                                                   |
| ---------------------------- | -------- | ----------------------------------------------------------------------------- |
| `MainBuildEntry`             | **Yes**  | Path to your build command.                                                   |
| `UIVariant`                  | **Yes**  | `"react"`, `"preact"`, or `"solid"`.                                          |
| `HTMLTemplateLocation`       | **Yes**  | HTML template path, relative to `StaticAssetDirs.Private`.                    |
| `ClientEntry`                | **Yes**  | Frontend entry file path.                                                     |
| `ClientRouteDefsFile`        | **Yes**  | Frontend route definitions file.                                              |
| `TSGenOutDir`                | **Yes**  | Directory for generated TypeScript types.                                     |
| `BuildtimePublicURLFuncName` | No       | Global function name for resolving asset URLs. Default: `"waveBuildtimeURL"`. |

### Vite Section (Required for Vite integration)

| Field                     | Required | Description                                     |
| ------------------------- | -------- | ----------------------------------------------- |
| `JSPackageManagerBaseCmd` | **Yes**  | `"npx"`, `"pnpm"`, `"yarn"`, or `"bunx"`.       |
| `JSPackageManagerCmdDir`  | No       | Directory to run commands from. Default: `"."`. |
| `DefaultPort`             | No       | Vite dev server port. Default: `5173`.          |

### Watch Section (Optional)

| Field                 | Description                                                     |
| --------------------- | --------------------------------------------------------------- |
| `HealthcheckEndpoint` | Endpoint polled during rebuilds. Default: `"/"`.                |
| `Include`             | Custom file watch patterns with hooks. Augments Vorma defaults. |
| `Exclude.Dirs`        | Directories to ignore. Use to carve out dirs from Include.      |
| `Exclude.Files`       | Files to ignore. Use to carve out files from Include.           |

---

## Step 2: Wave Initialization

Wave provides the filesystem and static asset handling. You need two files with
build tags to handle dev vs. prod differences.

### backend/wave.dev.go

```go
//go:build !prod

package backend

import (
    "os"
    "github.com/vormadev/vorma/kit/fsutil"
    "github.com/vormadev/vorma/wave"
)

var dirFS = os.DirFS("backend")

var Wave = wave.New(wave.Config{
    WaveConfigJSON: fsutil.MustReadFile(dirFS, "wave.config.json"),
    DistStaticFS:   fsutil.MustSub(dirFS, "dist", "static"),
})
```

### backend/wave.prod.go

```go
//go:build prod

package backend

import (
    "embed"
    "github.com/vormadev/vorma/kit/fsutil"
    "github.com/vormadev/vorma/wave"
)

//go:embed all:dist/static wave.config.json
var embedFS embed.FS

var Wave = wave.New(wave.Config{
    WaveConfigJSON: fsutil.MustReadFile(embedFS, "wave.config.json"),
    DistStaticFS:   fsutil.MustSub(embedFS, "dist", "static"),
})
```

**Why two files?** In development, files are read from disk for hot-reload. In
production, files are embedded in the binary for single-binary deployment. The
`prod` build tag is automatically set during production builds.

---

## Step 3: HTML Template

Create `backend/assets/entry.go.html`:

```html
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		{{.VormaHeadEls}} {{.VormaSSRScript}}
	</head>
	<body>
		<div id="{{.VormaRootID}}"></div>
		{{.VormaBodyScripts}}
	</body>
</html>
```

### Template Variables (Provided by Vorma)

| Variable                | Description                                                            |
| ----------------------- | ---------------------------------------------------------------------- |
| `{{.VormaHeadEls}}`     | **Required.** Renders `<title>`, `<meta>`, `<link>` tags from loaders. |
| `{{.VormaSSRScript}}`   | **Required.** Injects route data for client hydration.                 |
| `{{.VormaRootID}}`      | **Required.** The ID for the root element (always `"vorma-root"`).     |
| `{{.VormaBodyScripts}}` | **Required.** Loads client JavaScript.                                 |

You can add custom variables via `GetRootTemplateData` (covered later).

---

## Step 4: The Vorma App Instance

Create `backend/src/router/router.go`:

```go
package router

import (
    "net/http"
    "yourmodule/backend"
    "github.com/vormadev/vorma"
)

var App = vorma.NewVormaApp(vorma.VormaAppConfig{
    Wave: backend.Wave,
})
```

### VormaAppConfig Fields

```go
type VormaAppConfig struct {
    // Required
    Wave *wave.Wave

    // Optional callbacks
    GetDefaultHeadEls   func(r *http.Request, app *Vorma, h *HeadEls) error
    GetHeadDedupeKeys   func(h *HeadEls)
    GetRootTemplateData func(r *http.Request) (map[string]any, error)

    // Optional router customization
    LoadersRouterOptions LoadersRouterOptions
    ActionsRouterOptions ActionsRouterOptions

    // Optional TypeScript generation
    AdHocTypes  []*AdHocType
    ExtraTSCode string

    // Optional logging
    Logger *slog.Logger
}
```

---

## Step 5: Head Element Management

### GetDefaultHeadEls

Sets default `<head>` elements for every page:

```go
var App = vorma.NewVormaApp(vorma.VormaAppConfig{
    Wave: backend.Wave,
    GetDefaultHeadEls: func(r *http.Request, app *vorma.Vorma, h *vorma.HeadEls) error {
        h.Title("My App")
        h.Description("Welcome to my app")
        h.Link(
            h.Rel("icon"),
            h.Href(app.GetPublicURL("favicon.svg")),
            h.Type("image/svg+xml"),
        )
        return nil
    },
})
```

### HeadEls Methods

```go
// Title and meta
h.Title("Page Title")
h.Description("Page description")
h.Meta(h.Name("author"), h.Content("John Doe"))
h.Meta(h.Property("og:title"), h.Content("Open Graph Title"))
h.Meta(h.Charset("utf-8"))

// Links
h.Link(h.Rel("stylesheet"), h.Href("/styles.css"))
h.Link(h.Rel("canonical"), h.Href("https://example.com/page"))

// Scripts
h.Script(h.Src("/analytics.js"), h.Async())
h.Script(h.Type("application/ld+json"), h.InnerHTML(`{"@context":"..."}`))

// Attribute helpers
h.Rel("stylesheet")
h.Href("/path")
h.Src("/path")
h.Type("text/css")
h.Name("description")
h.Property("og:title")
h.Content("value")
h.Charset("utf-8")
h.Async()
h.Defer()
h.InnerHTML("content")
```

### GetHeadDedupeKeys

Prevents duplicate meta tags by defining which attributes make a tag unique:

```go
var App = vorma.NewVormaApp(vorma.VormaAppConfig{
    Wave: backend.Wave,
    GetHeadDedupeKeys: func(h *vorma.HeadEls) {
        // Only one og:title and og:description allowed
        h.Meta(h.Property("og:title"))
        h.Meta(h.Property("og:description"))
        // Only one description meta tag
        h.Meta(h.Name("description"))
    },
})
```

When a loader sets a head element matching a dedupe key, it replaces (not
duplicates) any earlier one.

---

## Step 6: Custom Template Data

Pass custom data to your HTML template:

```go
var App = vorma.NewVormaApp(vorma.VormaAppConfig{
    Wave: backend.Wave,
    GetRootTemplateData: func(r *http.Request) (map[string]any, error) {
        return map[string]any{
            "Environment": os.Getenv("ENV"),
            "BuildTime":   time.Now().Format(time.RFC3339),
        }, nil
    },
})
```

Then in `entry.go.html`:

```html
<body data-env="{{.Environment}}"></body>
```

---

## Step 7: Router Initialization

```go
package router

import (
    "net/http"
    "yourmodule/backend"
    "github.com/vormadev/vorma"
    "github.com/vormadev/vorma/kit/middleware/healthcheck"
)

func Init() (addr string, handler http.Handler) {
    r := App.InitWithDefaultRouter()

    // Register middleware
    r.SetGlobalHTTPMiddleware(App.ServeStatic())
    r.SetGlobalHTTPMiddleware(healthcheck.Healthz)

    return App.ServerAddr(), r
}

var App = vorma.NewVormaApp(vorma.VormaAppConfig{
    Wave: backend.Wave,
    // ... config
})
```

### InitWithDefaultRouter

`App.InitWithDefaultRouter()` does three things:

1. Calls `App.Init()` to load configuration and templates
2. Creates a new router
3. Registers the loaders handler (`GET /*`) and actions handlers
   (`POST/PUT/PATCH/DELETE /api/*`)

### Alternative: Manual Handler Registration

For custom routing needs:

```go
func Init() (addr string, handler http.Handler) {
    App.Init()

    r := mux.NewRouter()
    loaders := App.Loaders()
    actions := App.Actions()

    r.RegisterHandler("GET", loaders.HandlerMountPattern(), loaders.Handler())
    for method := range actions.SupportedMethods() {
        r.RegisterHandler(method, actions.HandlerMountPattern(), actions.Handler())
    }

    return App.ServerAddr(), r
}
```

### ServeStatic Middleware

`App.ServeStatic()` serves files from your public static directory with proper
cache headers:

- Hashed files (e.g., `vorma_out_image_abc123.png`):
  `Cache-Control: public, max-age=31536000, immutable`
- Checks if the request path matches a public asset before passing to the next
  handler

---

## Step 8: Defining Loaders

Loaders fetch data for routes. They run on the server and their output is
serialized to JSON for the client.

### Basic Pattern

```go
func NewLoader[O any](
    pattern string,
    loader vorma.LoaderFunc[LoaderCtx, O],
) *vorma.Loader[O] {
    return vorma.NewLoader(App, pattern, loader, decorateLoaderCtx)
}

type LoaderCtx struct {
    *vorma.LoaderReqData
}

func decorateLoaderCtx(rd *vorma.LoaderReqData) *LoaderCtx {
    return &LoaderCtx{LoaderReqData: rd}
}
```

### Defining Loaders

```go
// Root layout loader - runs for all routes under "/"
var _ = NewLoader("/", func(c *LoaderCtx) (*RootData, error) {
    return &RootData{
        SiteName: "My App",
        User:     getCurrentUser(c.R()),
    }, nil
})

// Index page loader
var _ = NewLoader("/_index", func(c *LoaderCtx) (*HomeData, error) {
    posts, err := db.GetRecentPosts()
    if err != nil {
        return nil, err
    }
    return &HomeData{Posts: posts}, nil
})

// Dynamic route loader
var _ = NewLoader("/users/:id", func(c *LoaderCtx) (*User, error) {
    id := c.Params()["id"]
    return db.GetUser(id)
})

// Splat route loader (catches all remaining path segments)
var _ = NewLoader("/files/*", func(c *LoaderCtx) (*FileInfo, error) {
    // c.SplatValues() returns []string of path segments after /files/
    path := strings.Join(c.SplatValues(), "/")
    return getFileInfo(path)
})
```

### Route Patterns

| Pattern                            | Matches                        | Parameters          |
| ---------------------------------- | ------------------------------ | ------------------- |
| `/`                                | Root layout (wraps all routes) | —                   |
| `/_index`                          | `/` exactly                    | —                   |
| `/about`                           | `/about`                       | —                   |
| `/users/:id`                       | `/users/123`, `/users/abc`     | `id`                |
| `/posts/:slug/comments/:commentId` | `/posts/hello/comments/42`     | `slug`, `commentId` |
| `/files/*`                         | `/files/a`, `/files/a/b/c`     | Splat values        |

**Convention:** `/_index` is the explicit index segment. The `/` pattern is a
layout that wraps child routes.

### Nested Routes and Layouts

Vorma uses nested routing. When a user visits `/posts/hello`:

1. The `/` loader runs (root layout)
2. The `/posts/:slug` loader runs

Both loaders' data is available to the frontend. The root layout component
renders an `<Outlet />` where child routes appear.

```go
// Root layout - provides site-wide data
var _ = NewLoader("/", func(c *LoaderCtx) (*SiteData, error) {
    return &SiteData{
        User: getCurrentUser(c.R()),
        Nav:  getNavItems(),
    }, nil
})

// Post page - nested under root
var _ = NewLoader("/posts/:slug", func(c *LoaderCtx) (*Post, error) {
    return db.GetPost(c.Params()["slug"])
})
```

You can also create intermediate layouts:

```go
// /dashboard layout - wraps all /dashboard/* routes
var _ = NewLoader("/dashboard", func(c *LoaderCtx) (*DashboardLayout, error) {
    return &DashboardLayout{
        Sidebar: getSidebarItems(),
    }, nil
})

// /dashboard (index page)
var _ = NewLoader("/dashboard/_index", func(c *LoaderCtx) (*DashboardHome, error) {
    return getDashboardStats()
})

// /dashboard/settings
var _ = NewLoader("/dashboard/settings", func(c *LoaderCtx) (*Settings, error) {
    return getUserSettings()
})
```

When visiting `/dashboard/settings`:

1. `/` loader runs
2. `/dashboard` loader runs
3. `/dashboard/settings` loader runs

### LoaderReqData Methods

```go
type LoaderCtx struct {
    *vorma.LoaderReqData
}

func (c *LoaderCtx) example() {
    // HTTP request
    r := c.R()
    w := c.W()

    // URL parameters from dynamic segments
    params := c.Params()        // map[string]string
    id := c.Params()["id"]

    // Splat values (for /* routes)
    segments := c.SplatValues() // []string

    // Response proxy for headers, redirects, head elements
    proxy := c.ResponseProxy()
}
```

### Setting Head Elements in Loaders

```go
var _ = NewLoader("/posts/:slug", func(c *LoaderCtx) (*Post, error) {
    post, err := db.GetPost(c.Params()["slug"])
    if err != nil {
        return nil, err
    }

    h := c.ResponseProxy().GetHeadEls()
    h.Title(post.Title)
    h.Meta(h.Property("og:title"), h.Content(post.Title))
    h.Meta(h.Property("og:description"), h.Content(post.Summary))

    return post, nil
})
```

### Redirects in Loaders

```go
var _ = NewLoader("/old-page", func(c *LoaderCtx) (vorma.None, error) {
    c.ResponseProxy().Redirect("/new-page", http.StatusMovedPermanently)
    return vorma.None{}, nil
})
```

### The None Type

`vorma.None` is an empty struct used when a loader or action has no meaningful
return value. It serializes to `{}` in JSON and generates
`Record<string, never>` in TypeScript.

```go
// Loader that only sets headers or redirects
var _ = NewLoader("/redirect", func(c *LoaderCtx) (vorma.None, error) {
    c.ResponseProxy().Redirect("/destination", http.StatusFound)
    return vorma.None{}, nil
})

// Action with no input
var _ = NewAction("POST", "/logout", func(c *ActionCtx[vorma.None]) (bool, error) {
    clearSession(c.R())
    return true, nil
})
```

### Setting Response Headers

```go
var _ = NewLoader("/api/data", func(c *LoaderCtx) (*Data, error) {
    c.ResponseProxy().SetHeader("X-Custom-Header", "value")
    c.ResponseProxy().SetHeader("Cache-Control", "max-age=3600")
    return getData()
})
```

### ResponseProxy Methods

The `ResponseProxy` provides safe access to response manipulation without
breaking Vorma's rendering:

```go
proxy := c.ResponseProxy()

// Headers
proxy.SetHeader("X-Custom", "value")

// Redirects (stops further processing)
proxy.Redirect("/new-url", http.StatusFound)           // 302
proxy.Redirect("/new-url", http.StatusMovedPermanently) // 301

// Head elements (for loaders)
h := proxy.GetHeadEls()
h.Title("Page Title")

// Status codes
proxy.SetStatus(http.StatusNotFound)
```

**Important:** Don't write directly to `c.W()` in loaders. Use `ResponseProxy`
to ensure proper JSON/HTML response handling.

---

## Step 9: Defining Actions

Actions handle mutations (POST, PUT, PATCH, DELETE). By default, they're mounted
at `/api/`.

### Basic Pattern

```go
func NewAction[I any, O any](
    method string,
    pattern string,
    action vorma.ActionFunc[ActionCtx[I], I, O],
) *vorma.Action[I, O] {
    return vorma.NewAction(App, method, pattern, action, decorateActionCtx)
}

type ActionCtx[I any] struct {
    *vorma.ActionReqData[I]
}

func decorateActionCtx[I any](rd *vorma.ActionReqData[I]) *ActionCtx[I] {
    return &ActionCtx[I]{ActionReqData: rd}
}
```

### Defining Actions

```go
// No input needed
var _ = NewAction("POST", "/increment", func(c *ActionCtx[vorma.None]) (int, error) {
    count++
    return count, nil
})

// With JSON input
type CreatePostInput struct {
    Title   string `json:"title"`
    Content string `json:"content"`
}

var _ = NewAction("POST", "/posts", func(c *ActionCtx[CreatePostInput]) (*Post, error) {
    input := c.Input()
    return db.CreatePost(input.Title, input.Content)
})

// With URL parameters
var _ = NewAction("DELETE", "/posts/:id", func(c *ActionCtx[vorma.None]) (bool, error) {
    id := c.Params()["id"]
    return db.DeletePost(id)
})

// With query parameters (GET actions)
type SearchInput struct {
    Query string `json:"q"`
    Limit int    `json:"limit"`
}

var _ = NewAction("GET", "/search", func(c *ActionCtx[SearchInput]) ([]Result, error) {
    input := c.Input()
    return db.Search(input.Query, input.Limit)
})
```

### Form Data Actions

For `multipart/form-data` or `application/x-www-form-urlencoded`:

```go
var _ = NewAction("POST", "/upload", func(c *ActionCtx[vorma.FormData]) (*UploadResult, error) {
    r := c.R()

    // Parse form manually
    if err := r.ParseMultipartForm(32 << 20); err != nil {
        return nil, err
    }

    file, header, err := r.FormFile("document")
    if err != nil {
        return nil, err
    }
    defer file.Close()

    // Process file...
    return &UploadResult{Filename: header.Filename}, nil
})
```

The `vorma.FormData` type signals to Vorma's TypeScript generator that the input
is `FormData`, not JSON.

### ActionReqData Methods

```go
type ActionCtx[I any] struct {
    *vorma.ActionReqData[I]
}

func (c *ActionCtx[I]) example() {
    // Parsed input (JSON body for POST/PUT/PATCH, query params for GET)
    input := c.Input()

    // HTTP request/response
    r := c.R()
    w := c.W()

    // URL parameters
    params := c.Params()

    // Response proxy
    proxy := c.ResponseProxy()
}
```

### Supported Methods

By default, actions support: `GET`, `POST`, `PUT`, `DELETE`, `PATCH`.

To customize:

```go
var App = vorma.NewVormaApp(vorma.VormaAppConfig{
    Wave: backend.Wave,
    ActionsRouterOptions: vorma.ActionsRouterOptions{
        SupportedMethods: []string{"GET", "POST"},
    },
})
```

### Actions Mount Root

Default: `/api/`. An action with pattern `/posts` is accessible at `/api/posts`.

To customize:

```go
var App = vorma.NewVormaApp(vorma.VormaAppConfig{
    Wave: backend.Wave,
    ActionsRouterOptions: vorma.ActionsRouterOptions{
        MountRoot: "/rpc/",
    },
})
```

---

## Step 10: Error Handling

### LoaderError

Return structured errors with separate client and server messages:

```go
var _ = NewLoader("/protected", func(c *LoaderCtx) (*Data, error) {
    user := getUser(c.R())
    if user == nil {
        return nil, &vorma.LoaderError{
            Client: "Please log in to view this page",
            Server: fmt.Errorf("unauthorized access attempt from IP %s", c.R().RemoteAddr),
        }
    }
    return getData(user)
})
```

- `Client`: Sent to the browser (safe for users to see)
- `Server`: Logged server-side (can contain sensitive details)

If you return a regular error, Vorma sends a generic "An error occurred" message
to the client and logs the full error server-side.

---

## Step 11: Build and Serve Commands

### backend/cmd/build/main.go

```go
package main

import (
    "yourmodule/backend/src/router"
    "github.com/vormadev/vorma/vormabuild"
)

func main() {
    vormabuild.Build(router.App)
}
```

`vormabuild.Build` handles:

- Parsing command-line flags
- Running the dev server (when `--dev`)
- Production builds (compiling Go, running Vite, processing assets)

### Build Command Flags

| Flag          | Description                                                               |
| ------------- | ------------------------------------------------------------------------- |
| `--dev`       | Run in development mode with hot reload                                   |
| `--no-binary` | Skip Go binary compilation (useful for CI/CD when you compile separately) |
| `--hook`      | Internal use: run build hook only (called by Wave during rebuilds)        |

**Usage:**

```bash
# Development
go run ./backend/cmd/build --dev

# Production build
go run ./backend/cmd/build

# Production without compiling binary
go run ./backend/cmd/build --no-binary
```

### package.json Scripts

Typically, you'll wrap these commands in npm scripts:

```json
{
	"scripts": {
		"dev": "go run ./backend/cmd/build --dev",
		"build": "go run ./backend/cmd/build"
	}
}
```

Then run:

```bash
npm run dev    # Development
npm run build  # Production
```

### backend/cmd/serve/main.go

```go
package main

import (
    "fmt"
    "net/http"
    "yourmodule/backend/src/router"
)

func main() {
    addr, handler := router.Init()
    fmt.Printf("Server starting at http://localhost%s\n", addr)
    http.ListenAndServe(addr, handler)
}
```

---

## Step 12: The dist/static Directory

Create `backend/dist/static/.keep`:

```
//go:embed directives require at least one file to compile
```

This file is required because Go's `//go:embed` directive fails if the directory
is empty. The build process populates this directory.

---

## Step 13: Custom Context Pattern

The decorator pattern lets you add custom methods to your context:

```go
type LoaderCtx struct {
    *vorma.LoaderReqData
}

func decorateLoaderCtx(rd *vorma.LoaderReqData) *LoaderCtx {
    return &LoaderCtx{LoaderReqData: rd}
}

// Custom methods
func (c *LoaderCtx) CurrentUser() *User {
    // Extract from session, JWT, etc.
    token := c.R().Header.Get("Authorization")
    return validateToken(token)
}

func (c *LoaderCtx) DB() *sql.DB {
    return globalDB
}

func (c *LoaderCtx) Logger() *slog.Logger {
    return slog.Default().With("request_id", c.R().Header.Get("X-Request-ID"))
}

// Usage
var _ = NewLoader("/dashboard", func(c *LoaderCtx) (*Dashboard, error) {
    user := c.CurrentUser()
    if user == nil {
        return nil, &vorma.LoaderError{Client: "Unauthorized"}
    }
    return c.DB().GetDashboard(user.ID)
})
```

---

## Step 14: TypeScript Generation

Vorma automatically generates TypeScript types for your loaders and actions.

### AdHocTypes

Add custom types to the generated TypeScript:

```go
type UserRole string

const (
    RoleAdmin  UserRole = "admin"
    RoleUser   UserRole = "user"
    RoleGuest  UserRole = "guest"
)

var App = vorma.NewVormaApp(vorma.VormaAppConfig{
    Wave: backend.Wave,
    AdHocTypes: []*vorma.AdHocType{
        {TypeInstance: UserRole("")},
    },
})
```

### ExtraTSCode

Inject raw TypeScript into the generated file:

```go
var App = vorma.NewVormaApp(vorma.VormaAppConfig{
    Wave: backend.Wave,
    ExtraTSCode: `
export type AppEnvironment = "development" | "staging" | "production";
export const API_VERSION = "v1" as const;
`,
})
```

---

## Step 15: Router Customization

### Dynamic Parameter Prefix

Default: `:` (e.g., `/users/:id`)

```go
var App = vorma.NewVormaApp(vorma.VormaAppConfig{
    Wave: backend.Wave,
    LoadersRouterOptions: vorma.LoadersRouterOptions{
        DynamicParamPrefix: '$', // Now: /users/$id
    },
    ActionsRouterOptions: vorma.ActionsRouterOptions{
        DynamicParamPrefix: '$',
    },
})
```

### Splat Segment Identifier

Default: `*` (e.g., `/files/*`)

```go
LoadersRouterOptions: vorma.LoadersRouterOptions{
    SplatSegmentIdentifier: '+', // Now: /files/+
},
```

### Index Segment Identifier

Default: `_index`

```go
LoadersRouterOptions: vorma.LoadersRouterOptions{
    IndexSegmentIdentifier: "__index", // Now: /__index
},
```

---

## Step 16: Using Third-Party Routers

If you want to use chi, gorilla/mux, or another router:

```go
import (
    "github.com/go-chi/chi/v5"
    "github.com/vormadev/vorma"
)

func Init() (addr string, handler http.Handler) {
    App.Init()

    r := chi.NewRouter()

    // REQUIRED: Inject Vorma's context middleware
    r.Use(vorma.EnableThirdPartyRouter)

    // Register Vorma handlers
    loaders := App.Loaders()
    actions := App.Actions()

    r.Get("/*", loaders.Handler().ServeHTTP)
    r.Post("/api/*", actions.Handler().ServeHTTP)
    // ... other methods

    return App.ServerAddr(), r
}
```

**Critical:** `vorma.EnableThirdPartyRouter` must be applied. Without it,
loaders and actions won't have access to the request context.

---

## Step 17: Utility Functions

### vorma.MustGetPort()

Returns the application port. In dev mode, finds a free port if the default is
taken.

```go
port := vorma.MustGetPort()
fmt.Printf("Running on port %d\n", port)
```

### vorma.GetIsDev()

Returns `true` if running in development mode.

```go
if vorma.GetIsDev() {
    // Enable debug logging, etc.
}
```

### vorma.SetModeToDev()

Manually set development mode (rarely needed—the build system handles this).

### vorma.IsJSONRequest(r \*http.Request)

Returns `true` if the request is asking for JSON data (client-side navigation).

```go
func customHandler(w http.ResponseWriter, r *http.Request) {
    if vorma.IsJSONRequest(r) {
        // Return JSON
    } else {
        // Return HTML
    }
}
```

### vorma.VormaBuildIDHeaderKey

The header key for the build ID: `"X-Vorma-Build-Id"`. Used for cache
invalidation.

---

## Step 18: Vorma Instance Methods

After creating the app, these methods are available:

```go
// Initialization
App.Init()                    // Initialize (panics on error)
App.InitWithDefaultRouter()   // Initialize and return configured router

// Handlers
App.Loaders()                 // Returns *Loaders (for manual registration)
App.Actions()                 // Returns *Actions (for manual registration)
App.ServeStatic()             // Returns middleware for static files

// Runtime info
App.ServerAddr()              // Returns ":PORT" string
App.GetIsDevMode()            // Returns true in dev mode
App.GetBuildID()              // Returns current build ID

// Routers (for advanced use)
App.LoadersRouter()           // Returns *LoadersRouter
App.ActionsRouter()           // Returns *ActionsRouter

// From embedded Wave instance
App.GetPublicURL("image.png") // Returns hashed URL like "/vorma_out_image_abc123.png"
App.Wave.GetCriticalCSS()     // Returns inlined CSS content
```

---

## Complete Example

```go
package router

import (
    "net/http"
    "yourmodule/backend"
    "github.com/vormadev/vorma"
    "github.com/vormadev/vorma/kit/middleware/healthcheck"
)

func Init() (addr string, handler http.Handler) {
    r := App.InitWithDefaultRouter()
    r.SetGlobalHTTPMiddleware(App.ServeStatic())
    r.SetGlobalHTTPMiddleware(healthcheck.Healthz)
    return App.ServerAddr(), r
}

var App = vorma.NewVormaApp(vorma.VormaAppConfig{
    Wave: backend.Wave,
    GetHeadDedupeKeys: func(h *vorma.HeadEls) {
        h.Meta(h.Property("og:title"))
        h.Meta(h.Property("og:description"))
    },
    GetDefaultHeadEls: func(r *http.Request, app *vorma.Vorma, h *vorma.HeadEls) error {
        h.Title("My App")
        h.Link(h.Rel("icon"), h.Href(app.GetPublicURL("favicon.svg")))
        return nil
    },
})

// Helpers
func NewLoader[O any](p string, f vorma.LoaderFunc[LoaderCtx, O]) *vorma.Loader[O] {
    return vorma.NewLoader(App, p, f, decorateLoaderCtx)
}
func NewAction[I, O any](m, p string, f vorma.ActionFunc[ActionCtx[I], I, O]) *vorma.Action[I, O] {
    return vorma.NewAction(App, m, p, f, decorateActionCtx)
}

type LoaderCtx struct{ *vorma.LoaderReqData }
type ActionCtx[I any] struct{ *vorma.ActionReqData[I] }

func decorateLoaderCtx(rd *vorma.LoaderReqData) *LoaderCtx { return &LoaderCtx{rd} }
func decorateActionCtx[I any](rd *vorma.ActionReqData[I]) *ActionCtx[I] { return &ActionCtx[I]{rd} }

// Loaders
type RootData struct{ SiteName string }

var _ = NewLoader("/", func(c *LoaderCtx) (*RootData, error) {
    return &RootData{SiteName: "My App"}, nil
})

var _ = NewLoader("/_index", func(c *LoaderCtx) (string, error) {
    return "Welcome!", nil
})

// Actions
var _ = NewAction("POST", "/contact", func(c *ActionCtx[ContactForm]) (bool, error) {
    input := c.Input()
    return sendEmail(input.Email, input.Message)
})

type ContactForm struct {
    Email   string `json:"email"`
    Message string `json:"message"`
}
```

---

## Summary: Required vs. Optional

### Required Files

- `wave.config.json` with Core and Vorma sections
- `entry.go.html` template with Vorma variables
- Wave initialization (`wave.dev.go` and `wave.prod.go`)
- `dist/static/.keep` for embed directive
- Build command (`cmd/build/main.go`)
- Serve command (`cmd/serve/main.go`)

### Required Code

- `vorma.NewVormaApp` with `Wave` field
- `App.Init()` or `App.InitWithDefaultRouter()`

### Optional but Recommended

- `GetDefaultHeadEls` for consistent meta tags
- `GetHeadDedupeKeys` to prevent duplicate meta tags
- Custom context decorators for dependency injection
- `ServeStatic()` middleware for public assets
- Healthcheck middleware for dev server coordination

### Conventions (Not Required)

- Directory structure (`backend/src/router/`, etc.)
- Naming (`App`, `NewLoader`, `NewAction`)
- Using `_` for unused loader/action return values
- Dynamic param syntax (`:id`) and splat syntax (`*`)
- Actions mount root (`/api/`)
